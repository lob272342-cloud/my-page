<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Will You Be My Valentine?</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div id="tsparticles"></div>
  
  <!-- Floating Hearts Container -->
  <div id="floating-hearts" class="floating-hearts-container"></div>
  
  <!-- Score Display -->
  <div id="hearts-score" class="hearts-score">‚ù§Ô∏è <span id="score-count">0</span></div>
  
  <!-- Interactive Frog -->
  <div id="interactive-frog" class="interactive-frog">
    <img src="transparent_frog.png" alt="interactive frog" />
  </div>
  
  <div class="card">
    <h1 class="question">My love, will you be my valentine?</h1>

    <div class="frog-wrap" aria-hidden="true">
      <img class="frog" src="frog.png" alt="cute frog holding a heart" />
    </div>

    <label for="editor" class="editor-label">Answer with Python:</label>
    <textarea id="editor" rows="3" spellcheck="false"></textarea>

    <div class="controls">
      <button id="run">Run ‚ñ∂</button>
      <button id="clear">Clear</button>
    </div>
    <div id="result" class="result" aria-live="polite"></div>
  </div>

  <script>
    // Utility function to escape HTML for safe display
    function escapeHtml(s) {
      return String(s)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }

    // State management
    let _daysSinceInterval = null;
    let _celebrateTimers = [];

    function runCode() {
      const code = document.getElementById('editor').value || '';
      const m = code.match(/print\((['"])([\s\S]*?)\1\)/);
      const captured = m ? m[2] : '';

      const result = document.getElementById('result');
      const normalized = captured ? captured.trim().toLowerCase().replace(/[!.?]+$/g, '') : '';
      const acceptedAnswers = ['yes', 'of course', 'absolutely', 'sure', 'definitely', 'yep', 'yeah', 'yup', 'absolutely', 'certainly', 'always'];
      
      if (acceptedAnswers.includes(normalized)) {
        // clear any existing interval
        if(_daysSinceInterval) { clearInterval(_daysSinceInterval); _daysSinceInterval = null; }

        result.innerHTML = `
          <div class="result-card">
            <h2>I love you <span class="heart-emoji">üíò</span></h2>
            
            <div class="countdown-box">
              <div class="countdown-label">Date Night In:</div>
              <div id="countdown" class="countdown"></div>
            </div>
            
            <div class="itinerary">
              <strong>Feb 14th</strong>
              <ul>
                <li>3:30 PM ‚Äî Early Dinner üçΩÔ∏è</li>
                <li>7:30 PM ‚Äî Cinema üçø</li>
              </ul>
            </div>
            <div class="code-snippet">
              <pre><code>import math

for moment in range(1, int(math.inf)):
    print("I love you ‚ù§Ô∏è")</code></pre>
            </div>
            <p class="ps">P.S. Our first date was <span id="days-since">...</span> days ago.</p>
            <p class="forever">I look forward to ‚àû more with you.</p>
            <div id="celebrate" class="celebrate" aria-hidden="true"></div>
          </div>
        `;

        // First date: 2025-08-01 18:00 London time (BST is UTC+1 in August)
        const firstDate = new Date('2025-08-01T18:00:00+01:00');
        // Date night: Feb 14th 2026 3:30 PM London time (GMT is UTC+0 in February)
        const dateNight = new Date('2026-02-14T15:30:00+00:00');

        function pad(n){ return String(n).padStart(2,'0'); }
        
        function updateCountdown() {
          const now = new Date();
          const diffMs = dateNight - now;
          const el = document.getElementById('countdown');
          if (!el) return;
          
          if (diffMs <= 0) {
            el.innerHTML = '<span class="countdown-complete">It\'s Date Night! üéâ</span>';
            return;
          }
          
          let diffSec = Math.floor(diffMs / 1000);
          const days = Math.floor(diffSec / 86400);
          diffSec = diffSec % 86400;
          const hours = Math.floor(diffSec / 3600);
          diffSec = diffSec % 3600;
          const minutes = Math.floor(diffSec / 60);
          const seconds = diffSec % 60;
          
          el.innerHTML = `
            <div class="countdown-segment">
              <span class="countdown-number">${days}</span>
              <span class="countdown-unit">days</span>
            </div>
            <div class="countdown-separator">:</div>
            <div class="countdown-segment">
              <span class="countdown-number">${pad(hours)}</span>
              <span class="countdown-unit">hours</span>
            </div>
            <div class="countdown-separator">:</div>
            <div class="countdown-segment">
              <span class="countdown-number">${pad(minutes)}</span>
              <span class="countdown-unit">mins</span>
            </div>
            <div class="countdown-separator">:</div>
            <div class="countdown-segment">
              <span class="countdown-number">${pad(seconds)}</span>
              <span class="countdown-unit">secs</span>
            </div>
          `;
        }
        
        function updateDaysSince(){
          const now = new Date();
          let diffSec = Math.floor((now - firstDate) / 1000);
          if(diffSec < 0) diffSec = 0;
          const days = Math.floor(diffSec / 86400);
          diffSec = diffSec % 86400;
          const hours = Math.floor(diffSec / 3600);
          diffSec = diffSec % 3600;
          const minutes = Math.floor(diffSec / 60);
          const seconds = diffSec % 60;
          const el = document.getElementById('days-since');
          if(el) el.textContent = `${days} days, ${pad(hours)}:${pad(minutes)}:${pad(seconds)} ago`;
        }

        // update immediately and then every 1s so it stays current
        updateCountdown();
        updateDaysSince();
        _daysSinceInterval = setInterval(() => {
          updateCountdown();
          updateDaysSince();
        }, 1000);

        // start small confetti/hearts celebration
        createCelebration();

      } else if (captured) {
        if (_daysSinceInterval) {
          clearInterval(_daysSinceInterval);
          _daysSinceInterval = null;
        }
        clearCelebration();
        result.innerHTML = `<pre class="output">${escapeHtml(captured)}</pre>`;
      } else {
        if (_daysSinceInterval) {
          clearInterval(_daysSinceInterval);
          _daysSinceInterval = null;
        }
        clearCelebration();
        result.innerHTML = `<pre class="output">No print() output detected.</pre>`;
      }
      result.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    // Event listeners
    document.getElementById('run').addEventListener('click', runCode);
    
    document.getElementById('clear').addEventListener('click', () => {
      document.getElementById('editor').value = '';
      document.getElementById('result').innerHTML = '';
      if (_daysSinceInterval) {
        clearInterval(_daysSinceInterval);
        _daysSinceInterval = null;
      }
      clearCelebration();
    });
    
    document.getElementById('editor').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
        runCode();
      }
    });

    // Celebration animation functions
    function createCelebration() {
      clearCelebration();
      const container = document.getElementById('celebrate');
      if (!container) return;
      const colors = ['#ffb3c6', '#ffd166', '#ffd1dc', '#9be89a', '#9ad0ff'];
      const total = 28;
      
      for (let i = 0; i < total; i++) {
        const el = document.createElement('div');
        const isHeart = Math.random() > 0.6;
        el.className = isHeart ? 'heart-piece' : 'confetti';
        el.style.left = Math.random() * 100 + '%';
        el.style.background = colors[Math.floor(Math.random() * colors.length)];
        el.style.transform = `translateY(0) rotate(${Math.random() * 360}deg)`;
        el.style.opacity = '0';
        container.appendChild(el);

        const delay = 80 + Math.random() * 800;
        const t = setTimeout(() => {
          el.style.opacity = '1';
          el.classList.add('fly');
        }, delay);
        _celebrateTimers.push(t);
        
        const removeT = setTimeout(() => {
          if (el.parentNode) el.parentNode.removeChild(el);
        }, delay + 3000);
        _celebrateTimers.push(removeT);
      }
      
      _celebrateTimers.push(setTimeout(() => clearCelebration(), 4500));
    }

    function clearCelebration() {
      const container = document.getElementById('celebrate');
      if (container) {
        container.innerHTML = '';
      }
      while (_celebrateTimers.length) {
        clearTimeout(_celebrateTimers.shift());
      }
    }

    // Interactive Frog Logic
    (function() {
      const frog = document.getElementById('interactive-frog');
      if (!frog) return;
      
      let frogX = Math.random() * (window.innerWidth - 80);
      let frogY = window.innerHeight - 100;
      let targetX = frogX;
      let targetY = frogY;
      let isJumping = false;
      
      frog.style.left = frogX + 'px';
      frog.style.bottom = '20px';
      
      // Random idle hopping
      function randomHop() {
        if (isJumping) return;
        const maxX = window.innerWidth - 80;
        targetX = Math.random() * maxX;
        jump();
      }
      
      let hopInterval = setInterval(randomHop, 3000 + Math.random() * 2000);
      
      // Mouse tracking
      let mouseX = -1000;
      let mouseY = -1000;
      
      document.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
        
        const rect = frog.getBoundingClientRect();
        const frogCenterX = rect.left + rect.width / 2;
        const frogCenterY = rect.top + rect.height / 2;
        
        const distance = Math.sqrt(
          Math.pow(mouseX - frogCenterX, 2) + 
          Math.pow(mouseY - frogCenterY, 2)
        );
        
        // If mouse gets too close, frog runs away
        if (distance < 150 && !isJumping) {
          const angle = Math.atan2(frogCenterY - mouseY, frogCenterX - mouseX);
          const jumpDistance = 150 + Math.random() * 100;
          targetX = frogCenterX + Math.cos(angle) * jumpDistance;
          targetY = frogCenterY + Math.sin(angle) * jumpDistance;
          
          // Keep within bounds
          const maxX = window.innerWidth - 80;
          targetX = Math.max(40, Math.min(maxX, targetX));
          targetY = Math.max(100, Math.min(window.innerHeight - 100, targetY));
          
          jump();
        }
      });
      
      function jump() {
        if (isJumping) return;
        isJumping = true;
        
        const startX = parseFloat(frog.style.left) || frogX;
        const startBottom = parseFloat(frog.style.bottom) || 20;
        const endX = targetX;
        
        // Flip frog if moving left
        if (endX < startX) {
          frog.style.transform = 'scaleX(-1)';
        } else {
          frog.style.transform = 'scaleX(1)';
        }
        
        frog.classList.add('jumping');
        
        const duration = 600;
        const startTime = performance.now();
        
        function animate(currentTime) {
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / duration, 1);
          
          // Easing function for smooth movement
          const eased = progress < 0.5 
            ? 2 * progress * progress 
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
          
          // Horizontal movement
          const currentX = startX + (endX - startX) * eased;
          frog.style.left = currentX + 'px';
          
          // Vertical jump arc
          const jumpHeight = 80 * Math.sin(progress * Math.PI);
          frog.style.bottom = (startBottom + jumpHeight) + 'px';
          
          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            frog.classList.remove('jumping');
            frogX = currentX;
            isJumping = false;
          }
        }
        
        requestAnimationFrame(animate);
      }
      
      // Handle window resize
      window.addEventListener('resize', () => {
        const maxX = window.innerWidth - 80;
        if (frogX > maxX) {
          frogX = maxX;
          frog.style.left = frogX + 'px';
        }
      });
    })();

    // Floating Hearts Game
    (function() {
      const container = document.getElementById('floating-hearts');
      const scoreDisplay = document.getElementById('hearts-score');
      const scoreCount = document.getElementById('score-count');
      if (!container || !scoreDisplay || !scoreCount) return;
      
      let score = 0;
      let celebratedAt10 = false;
      const messages = [
        'üíï', '+1', '‚ú®', 'Love!', 'Sweet!', 'üòç', 'üíñ', 
        'Cute!', 'Aww!', 'üíó', 'Perfect!', 'ü•∞', 'Amazing!'
      ];
      
      function triggerCelebrationShower() {
        const particles = ['‚≠ê', '‚ú®', 'üí´', 'üåü', 'üíñ', 'üíï', 'üíó', 'üíù', 'üéâ', 'üéä'];
        const particleCount = 50;
        
        for (let i = 0; i < particleCount; i++) {
          setTimeout(() => {
            const particle = document.createElement('div');
            particle.className = 'celebration-particle';
            particle.textContent = particles[Math.floor(Math.random() * particles.length)];
            
            // Random position across top of screen
            const startX = Math.random() * window.innerWidth;
            particle.style.left = startX + 'px';
            particle.style.top = '-50px';
            
            // Random fall properties
            const fallDistance = 600 + Math.random() * 400;
            const rotation = Math.random() * 720 - 360;
            const duration = 2 + Math.random() * 2;
            
            particle.style.setProperty('--fall-distance', fallDistance + 'px');
            particle.style.setProperty('--rotation', rotation + 'deg');
            particle.style.setProperty('--fall-duration', duration + 's');
            
            document.body.appendChild(particle);
            
            setTimeout(() => particle.remove(), duration * 1000);
          }, i * 50); // Stagger the particles
        }
      }
      
      function spawnHeart() {
        const heart = document.createElement('div');
        heart.className = 'floating-heart';
        heart.textContent = ['üíñ', 'üíï', 'üíó', 'üíì', 'üíù'][Math.floor(Math.random() * 5)];
        
        const startX = Math.random() * (window.innerWidth - 50);
        heart.style.left = startX + 'px';
        heart.style.bottom = '-50px';
        
        heart.addEventListener('click', function(e) {
          if (heart.classList.contains('popped')) return;
          
          score++;
          scoreCount.textContent = score;
          
          // Check if we just hit 10 points
          if (score === 10 && !celebratedAt10) {
            celebratedAt10 = true;
            triggerCelebrationShower();
          }
          
          // Pulse score display
          scoreDisplay.classList.remove('pulse');
          void scoreDisplay.offsetWidth; // trigger reflow
          scoreDisplay.classList.add('pulse');
          
          // Show pop message
          const msg = document.createElement('div');
          msg.className = 'pop-message';
          msg.textContent = messages[Math.floor(Math.random() * messages.length)];
          msg.style.left = e.clientX + 'px';
          msg.style.top = e.clientY + 'px';
          document.body.appendChild(msg);
          
          setTimeout(() => msg.remove(), 1500);
          
          // Pop the heart
          heart.classList.add('popped');
          setTimeout(() => heart.remove(), 400);
        });
        
        container.appendChild(heart);
        
        // Remove after animation completes
        setTimeout(() => {
          if (heart.parentNode) heart.remove();
        }, 8000);
      }
      
      // Spawn hearts at intervals
      setInterval(spawnHeart, 2000);
      
      // Spawn initial hearts
      for (let i = 0; i < 3; i++) {
        setTimeout(spawnHeart, i * 700);
      }
    })();

    // Mouse Trail Effect
    (function() {
      const particles = ['‚ú®', 'üíï', 'üí´', 'üåü', 'üíñ'];
      let lastTrailTime = 0;
      const trailDelay = 80; // milliseconds between particles
      
      document.addEventListener('mousemove', (e) => {
        const now = Date.now();
        if (now - lastTrailTime < trailDelay) return;
        lastTrailTime = now;
        
        // Only spawn occasionally (30% chance)
        if (Math.random() > 0.3) return;
        
        const particle = document.createElement('div');
        particle.className = 'trail-particle';
        particle.textContent = particles[Math.floor(Math.random() * particles.length)];
        particle.style.left = e.pageX + 'px';
        particle.style.top = e.pageY + 'px';
        
        // Random drift direction
        const tx = (Math.random() - 0.5) * 30;
        const ty = (Math.random() - 0.5) * 30;
        particle.style.setProperty('--tx', tx + 'px');
        particle.style.setProperty('--ty', ty + 'px');
        
        document.body.appendChild(particle);
        
        // Remove after animation
        setTimeout(() => particle.remove(), 1200);
      });
    })();

    // Shooting Stars
    (function() {
      function spawnShootingStar() {
        const star = document.createElement('div');
        star.className = 'shooting-star';
        
        // Random starting position (top area of screen)
        const startX = Math.random() * window.innerWidth;
        const startY = Math.random() * (window.innerHeight * 0.4); // top 40% of screen
        
        star.style.left = startX + 'px';
        star.style.top = startY + 'px';
        
        // Random angle (shooting downward and to the right mostly)
        const angle = -30 - (Math.random() * 30); // between -30 and -60 degrees
        const distance = 300 + Math.random() * 400; // travel distance
        const duration = 1 + Math.random() * 1.5; // 1-2.5 seconds
        const slope = Math.tan(angle * Math.PI / 180);
        
        star.style.setProperty('--angle', angle + 'deg');
        star.style.setProperty('--distance', distance + 'px');
        star.style.setProperty('--duration', duration + 's');
        star.style.setProperty('--slope', slope);
        
        document.body.appendChild(star);
        
        // Trigger animation
        requestAnimationFrame(() => {
          star.classList.add('shooting');
        });
        
        // Remove after animation
        setTimeout(() => star.remove(), duration * 1000 + 100);
      }
      
      function scheduleNextStar() {
        // Random interval between 8-20 seconds for rare occurrence
        const nextDelay = 8000 + Math.random() * 12000;
        setTimeout(() => {
          spawnShootingStar();
          scheduleNextStar();
        }, nextDelay);
      }
      
      // Start the cycle with initial delay
      setTimeout(() => {
        spawnShootingStar();
        scheduleNextStar();
      }, 3000); // first star after 3 seconds
    })();
  </script>

  <!-- Particles Animation -->
  <script src="https://cdn.jsdelivr.net/npm/tsparticles@2.12.0/tsparticles.bundle.min.js"></script>
  <script>
    // Initialize particles background
    tsParticles.load("tsparticles", {
      fullScreen: { enable: false },
      particles: {
        number: {
          value: 30,
          density: { enable: true, area: 800 }
        },
        color: {
          value: ["#ff6b9d", "#c44569", "#8e44ad", "#f39c12", "#e74c3c"]
        },
        shape: {
          type: ["circle", "heart", "star"],
          options: {
            heart: { particles: { size: { value: 8 } } },
            star: { sides: 5 }
          }
        },
        opacity: {
          value: 0.8,
          random: true,
          animation: {
            enable: true,
            speed: 0.8,
            minimumValue: 0.2,
            sync: false
          }
        },
        size: {
          value: { min: 3, max: 8 },
          random: true,
          animation: {
            enable: true,
            speed: 2,
            minimumValue: 2,
            sync: false
          }
        },
        move: {
          enable: true,
          speed: 1.5,
          direction: "bottom",
          random: true,
          straight: false,
          outModes: {
            default: "out",
            bottom: "out",
            top: "out"
          },
          attract: { enable: false }
        },
        rotate: {
          value: { min: 0, max: 360 },
          direction: "random",
          animation: {
            enable: true,
            speed: 3,
            sync: false
          }
        }
      },
      interactivity: {
        detectsOn: "canvas",
        events: {
          onHover: {
            enable: true,
            mode: "bubble"
          },
          resize: true
        },
        modes: {
          bubble: {
            distance: 150,
            size: 12,
            duration: 2,
            opacity: 0.8
          }
        }
      },
      detectRetina: true
    });
  </script>
</body>
</html>
